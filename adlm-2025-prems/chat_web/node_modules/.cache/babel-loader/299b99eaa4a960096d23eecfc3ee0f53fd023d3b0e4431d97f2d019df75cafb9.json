{"ast":null,"code":"var _process$env$REACT_AP;\nconst BASE_URL = (_process$env$REACT_AP = process.env.REACT_APP_API_BASE_URL) !== null && _process$env$REACT_AP !== void 0 ? _process$env$REACT_AP : \"http://localhost:8000/api\";\nasync function api(path, {\n  method = \"GET\",\n  body\n} = {}) {\n  const res = await fetch(`${BASE_URL}${path}`, {\n    method,\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: body !== undefined ? JSON.stringify(body) : undefined\n  });\n  if (!res.ok) {\n    const detail = await res.text().catch(() => \"\");\n    throw new Error(`${res.status} ${res.statusText} – ${detail}`);\n  }\n  return res.status === 204 ? null : res.json();\n}\nexport async function* streamChat(message) {\n  const res = await fetch(`${BASE_URL}/chat`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n      // no auth headers needed\n    },\n    body: JSON.stringify({\n      message\n    })\n  });\n  if (!res.ok || !res.body) {\n    const text = await res.text().catch(() => \"\");\n    throw new Error(`HTTP ${res.status}: ${text || res.statusText}`);\n  }\n\n  // stream parsing: the server yields newline-delimited lines\n  const reader = res.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  while (true) {\n    const {\n      value,\n      done\n    } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, {\n      stream: true\n    });\n\n    // process complete lines\n    let nl;\n    while ((nl = buffer.indexOf(\"\\n\")) >= 0) {\n      const line = buffer.slice(0, nl).trim();\n      buffer = buffer.slice(nl + 1);\n      if (!line) continue;\n\n      // line format: \"<type>: <payload>\"\n      const sep = line.indexOf(\":\");\n      if (sep === -1) {\n        yield {\n          type: \"unknown\",\n          raw: line\n        };\n        continue;\n      }\n      const type = line.slice(0, sep).trim();\n      const rawPayload = line.slice(sep + 1).trim();\n\n      // Some events carry JSON; reply payload is JSON-encoded string\n      let payload = rawPayload;\n      try {\n        payload = JSON.parse(rawPayload);\n      } catch {\n        // keep as raw string if not valid JSON\n      }\n      yield {\n        type,\n        payload\n      };\n    }\n  }\n}\nexport async function health() {\n  const r = await fetch(`${BASE_URL}/health`);\n  if (!r.ok) throw new Error(`Health check failed: ${r.status}`);\n  return r.json();\n}","map":{"version":3,"names":["BASE_URL","_process$env$REACT_AP","process","env","REACT_APP_API_BASE_URL","api","path","method","body","res","fetch","headers","undefined","JSON","stringify","ok","detail","text","catch","Error","status","statusText","json","streamChat","message","reader","getReader","decoder","TextDecoder","buffer","value","done","read","decode","stream","nl","indexOf","line","slice","trim","sep","type","raw","rawPayload","payload","parse","health","r"],"sources":["/Users/evelyn.goodman/ADLM-2025-Data-Challenge-PREMS/adlm-2025-prems/chat_web/src/apiClient.js"],"sourcesContent":["const BASE_URL = process.env.REACT_APP_API_BASE_URL ?? \"http://localhost:8000/api\";\n\nasync function api(path, { method = \"GET\", body } = {}) {\n    const res = await fetch(`${BASE_URL}${path}`, {\n        method,\n        headers: { \"Content-Type\": \"application/json\" },\n        body: body !== undefined ? JSON.stringify(body) : undefined,\n    });\n    if (!res.ok) {\n        const detail = await res.text().catch(() => \"\");\n        throw new Error(`${res.status} ${res.statusText} – ${detail}`);\n    }\n    return res.status === 204 ? null : res.json();\n}\n\nexport async function* streamChat(message) {\n    const res = await fetch(`${BASE_URL}/chat`, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            // no auth headers needed\n        },\n        body: JSON.stringify({ message }),\n    });\n\n    if (!res.ok || !res.body) {\n        const text = await res.text().catch(() => \"\");\n        throw new Error(`HTTP ${res.status}: ${text || res.statusText}`);\n    }\n\n    // stream parsing: the server yields newline-delimited lines\n    const reader = res.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n\n    while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, { stream: true });\n\n        // process complete lines\n        let nl;\n        while ((nl = buffer.indexOf(\"\\n\")) >= 0) {\n            const line = buffer.slice(0, nl).trim();\n            buffer = buffer.slice(nl + 1);\n\n            if (!line) continue;\n\n            // line format: \"<type>: <payload>\"\n            const sep = line.indexOf(\":\");\n            if (sep === -1) {\n                yield { type: \"unknown\", raw: line };\n                continue;\n            }\n\n            const type = line.slice(0, sep).trim();\n            const rawPayload = line.slice(sep + 1).trim();\n\n            // Some events carry JSON; reply payload is JSON-encoded string\n            let payload = rawPayload;\n            try {\n                payload = JSON.parse(rawPayload);\n            } catch {\n                // keep as raw string if not valid JSON\n            }\n\n            yield { type, payload };\n        }\n    }\n}\n\nexport async function health() {\n    const r = await fetch(`${BASE_URL}/health`);\n    if (!r.ok) throw new Error(`Health check failed: ${r.status}`);\n    return r.json();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}